const yaml = require("js-yaml");
const utils = require("../helpers/utils");
const PORT = 8080;
const HOST = "localhost";
const pdfjsLib = require("pdfjs-dist");

let defPdfConfigFilePath = "../configs/pdf-run-info.yml";
let acceptableRunModes = {
  configureBaseline: "create-baseline",
  compareReleaseWithBaseline: "compare-release-with-baseline",
};
let pdfjsServerProjectsDir = __dirname + "/../pdfjs-3.4.120-dist/web/projects";
let userProjectsSourceDir = __dirname + "/../projects";
let fileEncoding = "utf8";

let pdfServerBaseUrl = `http://${HOST}:${PORT}`;
let pdfViewerUrlPath = "/web/viewer.html?file=/web/projects";

let percyAutoGenConfigFolder = __dirname + "/../.dist";
let percyAutoGenConfigFileNamePrefix = "snapshots_";
let percyAutoGenConfigFileExt = ".yml";
let percyDefaultBranchPrefix = "DOC"

let percyWaitForSelectorCss = "div#viewer > div.page[data-loaded]";
let percyStaticExecuteScriptBeforeSnapshot =
  "document.querySelector('div#viewer').children.item(0).remove();\ndocument.querySelector('div#viewer').children.length == 1\n  ? document.querySelector('button#next').click()\n  : document\n      .querySelector('div#viewer')\n      .children.item(1)\n      .scrollIntoView();\ndocument\n  .querySelector('div#viewer')\n  .children.item(0)\n  .scrollIntoView();\n";
let percyExecuteScriptReferenceObj = "*restore-page-state";

async function setup() {
  // recreate any existing auto generated folders
  await utils.recreateFolder(pdfjsServerProjectsDir, true);
  await utils.recreateFolder(percyAutoGenConfigFolder, true);

  // copy projects directory from user's project folder to PDFJS local server folder
  await utils.copyFolder(userProjectsSourceDir, pdfjsServerProjectsDir, true);
}

async function readPdfDocsRunInfoConfigs() {
  const args = process.argv.slice(2);
  // Read PDF Docs Run Info Config File supplied by the user.
  // If not found, throw an error and stop the run.
  if (args.length > 0) {
    defPdfConfigFilePath = args[0];
  } else {
    console.error(
      "Please provide the PDF Docs Run Info Configs File path, as a Node Process argument. e.g. npm test config/pdf-docs-run-info-baseline.yml"
    );
    process.exit(1);
  }

  return yaml.load(await utils.readFile(defPdfConfigFilePath, fileEncoding));
}

async function triggerPercyProcess(
  percyConfigFilePath,
  percyBranch,
  percyTargetBranch
) {
  // Trigger Percy built-in automation to process the relevant autogenerated Snapshot Files.
  await utils.startExternalProcess(
    "npx",
    [`percy snapshot "${percyConfigFilePath}";`],
    {
      shell: true,
      stdio: "inherit",
      env: {
        ...process.env,
        PERCY_BRANCH: `${percyBranch.replace(/\s/g, "")}`,
        PERCY_TARGET_BRANCH: `${percyTargetBranch.replace(/\s/g, "")}`,
      },
    }
  );
}

async function createPdfDocsRunInfoMap(
  rootConfig,
  allIncludedFilesMap,
  fileName,
  projectFolderName,
  pdfPageCount
) {
  // Create Mapping of Incoming YML file with few additional attributes

  let pdfDocsRunInfoMap = {
    runMode: rootConfig["runMode"],
    baselineDir: rootConfig["baselineDir"],
    releaseDir: rootConfig["releaseDir"],
    pdfDocId: "",
    projectFolder: projectFolderName,
    pdfFileName: fileName,
    pdfPageCount: pdfPageCount,
    includePages:
      allIncludedFilesMap.get(fileName) == undefined
        ? []
        : allIncludedFilesMap.get(fileName)["includePages"],
    excludePages:
      allIncludedFilesMap.get(fileName) == undefined
        ? []
        : allIncludedFilesMap.get(fileName)["excludePages"],
    percyBranch: "",
    percyTargetBranch: "",
    finalWorkingDir: "",
  };

  // Set appropriate environment variables and working folder as per PDF Docs Run Info User config file.

  if (pdfDocsRunInfoMap.runMode == acceptableRunModes.configureBaseline) {
    pdfDocsRunInfoMap.finalWorkingDir = pdfDocsRunInfoMap.baselineDir;
    pdfDocsRunInfoMap.pdfDocId = `${percyDefaultBranchPrefix}_${projectFolderName}_${pdfDocsRunInfoMap.finalWorkingDir}_${fileName}`;
    pdfDocsRunInfoMap.percyBranch = `${pdfDocsRunInfoMap.pdfDocId}`;
    pdfDocsRunInfoMap.percyTargetBranch = "";
  } else if (
    pdfDocsRunInfoMap.runMode == acceptableRunModes.compareReleaseWithBaseline
  ) {
    pdfDocsRunInfoMap.finalWorkingDir = pdfDocsRunInfoMap.releaseDir;
    pdfDocsRunInfoMap.pdfDocId = `${percyDefaultBranchPrefix}_${projectFolderName}_${pdfDocsRunInfoMap.finalWorkingDir}_${fileName}`;
    pdfDocsRunInfoMap.percyBranch = `${pdfDocsRunInfoMap.pdfDocId}`;
    pdfDocsRunInfoMap.percyTargetBranch = `${percyDefaultBranchPrefix}_${projectFolderName}_${pdfDocsRunInfoMap.baselineDir}_${fileName}`;
  } else {
    console.error(
      `'runMode' found: ${pdfDocsRunInfoMap.runMode}.\nIt should be either '${acceptableRunModes.configureBaseline}' OR '${acceptableRunModes.compareReleaseWithBaseline}'.\nPlease update ${defPdfConfigFilePath}.`
    );
    process.exit(1);
  }

  return pdfDocsRunInfoMap;
}

async function createPercySnapshotConfig(pdfDocsRunInfoMap) {
  let additionalSnapshotsForEachPage = [];

  let snapshotPagesArr = Array.from(
    { length: pdfDocsRunInfoMap.pdfPageCount - 1 },
    (_, index) => index + 2
  );

  pdfDocsRunInfoMap.includePages.length == 0
    ? snapshotPagesArr
    : (snapshotPagesArr = snapshotPagesArr.filter((value) =>
        pdfDocsRunInfoMap.includePages.includes(value)
      ));
  pdfDocsRunInfoMap.excludePages.length == 0
    ? snapshotPagesArr
    : (snapshotPagesArr = snapshotPagesArr.filter(
        (value) => !pdfDocsRunInfoMap.excludePages.includes(value)
      ));

  console.info(
    `Pages considered for snapshot in DOC: ${pdfDocsRunInfoMap.pdfDocId.replace(
      /\s/g,
      ""
    )} => [1,${snapshotPagesArr}]`
  );

  snapshotPagesArr.forEach((item, index) => {
    let nextIndex = item;
    let currentIndex = 1;
    let percyDynExecuteScriptBeforeSnapshot =
      "let nextIndex = $$dynamicNextIndex$$;\nfor(currentIndex = $$dynamicCurrentIndex$$;currentIndex < nextIndex; currentIndex++)\n{\ndocument.querySelector('div#viewer').children.item(0).remove();\n}\ndocument.querySelector('div#viewer').children.length == 1\n  ? document.querySelector('button#next').click()\n  : document\n      .querySelector('div#viewer')\n      .children.item(1)\n      .scrollIntoView();\ndocument\n  .querySelector('div#viewer')\n  .children.item(0)\n  .scrollIntoView();\n";
    snapshotPagesArr[index - 1] == undefined
      ? currentIndex
      : (currentIndex = snapshotPagesArr[index - 1]);
    percyDynExecuteScriptBeforeSnapshot = percyDynExecuteScriptBeforeSnapshot
      .replace("$$dynamicNextIndex$$", nextIndex)
      .replace("$$dynamicCurrentIndex$$", currentIndex);

    if (
      pdfDocsRunInfoMap.includePages.length == 0 &&
      pdfDocsRunInfoMap.excludePages.length == 0
    ) {
      additionalSnapshotsForEachPage.push({
        suffix: ` | Page ${item}`,
        waitForSelector: percyWaitForSelectorCss,
        execute: percyExecuteScriptReferenceObj,
      });
    } else {
      additionalSnapshotsForEachPage.push({
        suffix: ` | Page ${item}`,
        waitForSelector: percyWaitForSelectorCss,
        execute: percyDynExecuteScriptBeforeSnapshot,
      });
    }
  });

  let snapshotConfigObj = {
    "base-url": pdfServerBaseUrl,
    references: {
      "restore-page-state": `${percyStaticExecuteScriptBeforeSnapshot}`,
    },
    snapshots: [
      {
        name: pdfDocsRunInfoMap.pdfFileName,
        url: `${pdfViewerUrlPath}/${pdfDocsRunInfoMap.projectFolder}/${pdfDocsRunInfoMap.finalWorkingDir}/${pdfDocsRunInfoMap.pdfFileName}`,
        waitForSelector: percyWaitForSelectorCss,
        additionalSnapshots: additionalSnapshotsForEachPage,
      },
    ],
  };

  return snapshotConfigObj;
}

async function furtherCleanseYmlFile(ymlContent) {
  ymlContent = await utils.replaceContentInFile(
    ymlContent,
    "restore-page-state: |",
    "restore-page-state: &restore-page-state | "
  );

  ymlContent = await utils.replaceContentInFile(
    ymlContent,
    /execute: '\*restore-page-state'/g,
    "execute: *restore-page-state"
  );

  return ymlContent;
}

async function processPdfDocsRunInfoConfigs(rootConfig) {
  try {
    if (rootConfig["projectFolders"] != null) {
      rootConfig["projectFolders"].forEach((projectFolderName) => {
        console.info("Project folder found: " + projectFolderName);
        let projectReleaseFolderPath = `./projects/${projectFolderName}/${rootConfig["baselineDir"]}`;
        let allIncludedFiles = utils.getFileNames(
          projectReleaseFolderPath,
          ".pdf"
        );

        if (rootConfig["includeDocs"] != null) {
          allIncludedFiles = allIncludedFiles.filter(function (el) {
            let currProjectDocs = rootConfig["includeDocs"].filter(function (
              docs
            ) {
              return docs["project"] == projectFolderName;
            });

            return currProjectDocs.map((obj) => obj["doc"]).includes(el);
          });
        }

        if (rootConfig["excludeDocs"] != null) {
          allIncludedFiles = allIncludedFiles.filter(function (el) {
            let currProjectDocs = rootConfig["excludeDocs"].filter(function (
              docs
            ) {
              return docs["project"] == projectFolderName;
            });
            return !currProjectDocs.map((obj) => obj["doc"]).includes(el);
          });
        }

        let allIncludedFilesMap = new Map();
        // console.log(`Special Doc Configs: ${rootConfig["specialDocConfigs"]}`);
        if (rootConfig["specialDocConfigs"] != null) {
          rootConfig["specialDocConfigs"].forEach((specialConfig) => {
           // console.log("Condition check: " + allIncludedFiles.includes(specialConfig["doc"]) && projectFolderName == specialConfig["project"])
            if (allIncludedFiles.includes(specialConfig["doc"]) && projectFolderName == specialConfig["project"]) {
              allIncludedFilesMap.set(specialConfig["doc"], {
                includePages: specialConfig["includePages"],
                excludePages: specialConfig["excludePages"],
              });
            }
          });
        }

        allIncludedFiles.forEach(async (fileName) => {
          let pdfPageCount = await pdfjsLib
            .getDocument(`${projectReleaseFolderPath}/${fileName}`)
            .promise.then(function (doc) {
              return doc.numPages;
            });

          let pdfDocsRunInfoMap = await createPdfDocsRunInfoMap(
            rootConfig,
            allIncludedFilesMap,
            fileName,
            projectFolderName,
            pdfPageCount
          );
          let snapshotConfigObj = await createPercySnapshotConfig(
            pdfDocsRunInfoMap
          );

          let ymlSnapshotConfigStr = yaml.dump(snapshotConfigObj);

          ymlSnapshotConfigStr = await furtherCleanseYmlFile(
            ymlSnapshotConfigStr
          );

          let percyConfigFilePath = await utils.writeContentToFile(
            ymlSnapshotConfigStr,
            percyAutoGenConfigFolder,
            percyAutoGenConfigFileNamePrefix +
              pdfDocsRunInfoMap.pdfDocId.replace(/\s/g, "") +
              "_" +
              pdfDocsRunInfoMap.finalWorkingDir +
              percyAutoGenConfigFileExt,
            fileEncoding
          );

          await triggerPercyProcess(
            percyConfigFilePath,
            pdfDocsRunInfoMap.percyBranch,
            pdfDocsRunInfoMap.percyTargetBranch
          );
        });
      });
    }
  } catch (e) {
    console.error(e);
  }
}

(async () => {
  try {
    await setup();
    let pdfDocsRunInfoConfigObj = await readPdfDocsRunInfoConfigs();
    await processPdfDocsRunInfoConfigs(pdfDocsRunInfoConfigObj);
  } catch (e) {
    console.error("Encountered Fatal Error: " + e);
    throw e;
  }
})();
