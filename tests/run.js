const yaml = require("js-yaml");
const utils = require("../helpers/utils");
const PORT = 8080;
const HOST = "localhost";

let defPdfConfigFilePath = "../configs/pdf-run-info.yml";
let acceptableRunModes = {
  configureBaseline: "configure-baseline",
  compareReleaseWithBaseline: "compare-release-with-baseline",
};
let pdfjsServerProjectsDir = __dirname + "/../pdfjs-3.4.120-dist/web/projects";
let userProjectsSourceDir = __dirname + "/../projects";
let fileEncoding = "utf8";

let pdfServerBaseUrl = `http://${HOST}:${PORT}`;
let pdfViewerUrlPath = "/web/viewer.html?file=/web/projects";

let percyAutoGenConfigFolder = __dirname + "/../.percy-auto-generated-configs";
let percyAutoGenConfigFileNamePrefix = "snapshots_";
let percyAutoGenConfigFileExt = ".yml";

let percyWaitForSelectorCss = "div#viewer > div.page[data-loaded]";
let percyStaticExecuteScriptBeforeSnapshot =
"document.querySelector('div#viewer').children.item(0).remove();\ndocument.querySelector('div#viewer').children.length == 1\n  ? document.querySelector('button#next').click()\n  : document\n      .querySelector('div#viewer')\n      .children.item(1)\n      .scrollIntoView();\ndocument\n  .querySelector('div#viewer')\n  .children.item(0)\n  .scrollIntoView();\n";
let percyExecuteScriptReferenceObj = "*restore-page-state";

async function setup() {
  // recreate any existing auto generated folders
  await utils.recreateFolder(pdfjsServerProjectsDir, true);
  await utils.recreateFolder(percyAutoGenConfigFolder, true);

  // copy projects directory from user's project folder to PDFJS local server folder
  await utils.copyFolder(userProjectsSourceDir, pdfjsServerProjectsDir, true);
}

async function readPdfDocsRunInfoConfigs() {
  const args = process.argv.slice(2);
  // Read PDF Docs Run Info Config File supplied by the user.
  // If not found, throw an error and stop the run.
  if (args.length > 0) {
    defPdfConfigFilePath = args[0];
  } else {
    console.error(
      "Please provide the PDF Docs Run Info Configs File path, as a Node Process argument. e.g. npm test config/pdf-docs-run-info-baseline.yml"
    );
    process.exit(1);
  }

  return yaml.load(await utils.readFile(defPdfConfigFilePath, fileEncoding));
}

async function triggerPercyProcess(
  percyConfigFilePath,
  percyBranch,
  percyTargetBranch
) {
  // Trigger Percy built-in automation to process the relevant autogenerated Snapshot Files.
  await utils.startExternalProcess("npx", [`percy snapshot ${percyConfigFilePath}; exit 0;`], {
    shell: true,
    stdio: "inherit",
    env: {
      ...process.env,
      PERCY_BRANCH: percyBranch,
      PERCY_TARGET_BRANCH: percyTargetBranch,
    },
  });
}

async function createPdfDocsRunInfoMap(item) {
  // Create Mapping of Incoming YML file with few additional attributes
  let pdfDocsRunInfoMap = {
    pdfDocId: item["pdfDocId"],
    projectFolder: item["projectFolder"],
    pdfFileName: item["pdfFileName"],
    pdfPageCount: item["pdfPageCount"],
    includePages: item["includePages"],
    excludePages: item["excludePages"],
    runMode: item["runMode"],
    baselineDir: item["baselineDir"],
    releaseDir: item["releaseDir"],
    percyBranch: "",
    percyTargetBranch: "",
    finalWorkingDir: "",
  };

  // Set appropriate environment variables and working folder as per PDF Docs Run Info User config file.

  if (pdfDocsRunInfoMap.runMode == acceptableRunModes.configureBaseline) {
    pdfDocsRunInfoMap.percyBranch = `${pdfDocsRunInfoMap.pdfDocId}_${pdfDocsRunInfoMap.baselineDir}`;
    pdfDocsRunInfoMap.percyTargetBranch = "";
    pdfDocsRunInfoMap.finalWorkingDir = pdfDocsRunInfoMap.baselineDir;
  } else if (
    pdfDocsRunInfoMap.runMode == acceptableRunModes.compareReleaseWithBaseline
  ) {
    pdfDocsRunInfoMap.percyBranch = `${pdfDocsRunInfoMap.pdfDocId}_${pdfDocsRunInfoMap.releaseDir}`;
    pdfDocsRunInfoMap.percyTargetBranch = `${pdfDocsRunInfoMap.pdfDocId}_${pdfDocsRunInfoMap.baselineDir}`;
    pdfDocsRunInfoMap.finalWorkingDir = pdfDocsRunInfoMap.releaseDir;
  } else {
    console.error(
      `'runMode' found: ${pdfDocsRunInfoMap.runMode}.\nIt should be either 'configure-baseline' or 'compare-release-with-baseline'.\nPlease update ${defPdfConfigFilePath}.`
    );
    process.exit(1);
  }

  return pdfDocsRunInfoMap;
}

async function createPercySnapshotConfig(pdfDocsRunInfoMap) {
  let additionalSnapshotsForEachPage = [];

  let snapshotPagesArr = Array.from(
    { length: pdfDocsRunInfoMap.pdfPageCount - 1 },
    (_, index) => index + 2
  );

  pdfDocsRunInfoMap.includePages.length == 0
    ? snapshotPagesArr
    : (snapshotPagesArr = snapshotPagesArr.filter((value) =>
        pdfDocsRunInfoMap.includePages.includes(value)
      ));
  pdfDocsRunInfoMap.excludePages.length == 0
    ? snapshotPagesArr
    : (snapshotPagesArr = snapshotPagesArr.filter(
        (value) => !pdfDocsRunInfoMap.excludePages.includes(value)
      ));

  console.log(
    `${pdfDocsRunInfoMap.pdfDocId} -  Pages considered for snapshot: [1,${snapshotPagesArr}]`
  );

  snapshotPagesArr.forEach((item, index) => {
    let nextIndex = item;
    let currentIndex = 1;
    let percyDynExecuteScriptBeforeSnapshot =
  "let nextIndex = $$dynamicNextIndex$$;\nfor(currentIndex = $$dynamicCurrentIndex$$;currentIndex < nextIndex; currentIndex++)\n{\ndocument.querySelector('div#viewer').children.item(0).remove();\n}\ndocument.querySelector('div#viewer').children.length == 1\n  ? document.querySelector('button#next').click()\n  : document\n      .querySelector('div#viewer')\n      .children.item(1)\n      .scrollIntoView();\ndocument\n  .querySelector('div#viewer')\n  .children.item(0)\n  .scrollIntoView();\n";
    snapshotPagesArr[index - 1] == undefined ? currentIndex : currentIndex = snapshotPagesArr[index - 1];
    percyDynExecuteScriptBeforeSnapshot = percyDynExecuteScriptBeforeSnapshot.replace(
      "$$dynamicNextIndex$$",
      nextIndex
    ).replace(
      "$$dynamicCurrentIndex$$",
      currentIndex
    );

    if(pdfDocsRunInfoMap.includePages.length == 0 && pdfDocsRunInfoMap.excludePages.length == 0) {
      additionalSnapshotsForEachPage.push({
      suffix: ` | Page ${item}`,
      waitForSelector: percyWaitForSelectorCss,
      execute: percyExecuteScriptReferenceObj,
    });
    } else {
      additionalSnapshotsForEachPage.push({
        suffix: ` | Page ${item}`,
        waitForSelector: percyWaitForSelectorCss,
        execute: percyDynExecuteScriptBeforeSnapshot,
      });

    }
  });

  let snapshotConfigObj = {
    "base-url": pdfServerBaseUrl,
    references: {
      "restore-page-state": `${percyStaticExecuteScriptBeforeSnapshot}`,
    },
    snapshots: [
      {
        name: pdfDocsRunInfoMap.pdfFileName,
        url: `${pdfViewerUrlPath}/${pdfDocsRunInfoMap.projectFolder}/${pdfDocsRunInfoMap.finalWorkingDir}/${pdfDocsRunInfoMap.pdfFileName}.pdf`,
        waitForSelector: percyWaitForSelectorCss,
        additionalSnapshots: additionalSnapshotsForEachPage,
      },
    ],
  };

  return snapshotConfigObj;
}

async function furtherCleanseYmlFile(ymlContent) {
  ymlContent = await utils.replaceContentInFile(
    ymlContent,
    "restore-page-state: |",
    "restore-page-state: &restore-page-state | "
  );

  ymlContent = await utils.replaceContentInFile(
    ymlContent,
    /execute: '\*restore-page-state'/g,
    "execute: *restore-page-state"
  );

  return ymlContent;
}

async function processPdfDocsRunInfoConfigs(configs) {
  try {
    [...configs].forEach(async (pdfDocRunInfoConfig) => {
      let pdfDocsRunInfoMap = await createPdfDocsRunInfoMap(
        pdfDocRunInfoConfig
      );
      let snapshotConfigObj = await createPercySnapshotConfig(
        pdfDocsRunInfoMap
      );

      let ymlSnapshotConfigStr = yaml.dump(snapshotConfigObj);

      ymlSnapshotConfigStr = await furtherCleanseYmlFile(ymlSnapshotConfigStr);

      let percyConfigFilePath = await utils.writeContentToFile(
        ymlSnapshotConfigStr,
        percyAutoGenConfigFolder,
        percyAutoGenConfigFileNamePrefix +
          pdfDocsRunInfoMap.pdfDocId +
          "_" +
          pdfDocsRunInfoMap.finalWorkingDir +
          percyAutoGenConfigFileExt,
        fileEncoding
      );

      await triggerPercyProcess(
        percyConfigFilePath,
        pdfDocsRunInfoMap.percyBranch,
        pdfDocsRunInfoMap.percyTargetBranch
      );
    });
  } catch (e) {
    console.error(e);
  }
}

(async () => {
  try {
    await setup();
    let pdfDocsRunInfoConfigObj = await readPdfDocsRunInfoConfigs();
    await processPdfDocsRunInfoConfigs(pdfDocsRunInfoConfigObj);
  } catch (e) {
    console.error("Encountered Fatal Error: " + e);
    throw e;
  }
})();
