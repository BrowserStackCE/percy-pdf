const utils = require('../helpers/utils')
const path = require('path')
let PORT = 8080
const HOST = 'localhost'

let defPdfConfigFilePath = '../configs/pdf-run-info.yml'
const acceptableRunModes = {
  configureBaseline: 'create-baseline',
  compareReleaseWithBaseline: 'compare-release-with-baseline'
}
const pdfjsServerProjectsDir = path.join(
  __dirname,
  '/../pdfjs-3.4.120-dist/web/projects'
)
const userProjectsSourceDir = path.join(__dirname, '/../projects')
const fileEncoding = 'utf8'

let pdfServerBaseUrl = `http://${HOST}:${PORT}`
const pdfViewerUrlPath = '/web/viewer.html?file=/web/projects'

const percyAutoGenConfigFolder = path.join(__dirname, '/../.dist')
const percyAutoGenConfigFileNamePrefix = 'ss_'
const percyAutoGenConfigFileExt = '.yml'
const percyDefaultBranchPrefix = 'DOC'

const percyWaitForSelectorCss = 'div#viewer > div.page[data-loaded]'
const percyStaticExecuteScriptBeforeSnapshot =
  "document.querySelector('div#viewer').children.item(0).remove();\ndocument.querySelector('div#viewer').children.length == 1\n  ? document.querySelector('button#next').click()\n  : document\n      .querySelector('div#viewer')\n      .children.item(1)\n      .scrollIntoView();\ndocument\n  .querySelector('div#viewer')\n  .children.item(0)\n  .scrollIntoView();\n"
const percyExecuteScriptReferenceObj = '*restore-page-state'

let pdfDocsRunInfoMap = new Map()

async function readArgs () {
  const args = process.argv.slice(2)
  // Read PDF Docs Run Info Config File supplied by the user, as the first process argument.
  // If not found, throw an error and stop the run.
  if (args.length > 0) {
    defPdfConfigFilePath = args[0]

    // Update PORT is provided by the user, as the second process argument
    if (args[1] != null) {
      PORT = args[1]
      pdfServerBaseUrl = `http://${HOST}:${PORT}`
    }
  } else {
    console.error(
      'Please provide the PDF Docs Run Info Configs File path, as a Node Process argument. e.g. npm test configs/getting-started-scenarios/01_pdf-docs-run-info-baseline.yml'
    )
    process.exit(1)
  }
}

async function setup () {
  await utils.startExternalProcess(
    `npx forever start "node_modules/http-server/bin/http-server" "-s" "-p ${PORT}" "pdfjs-3.4.120-dist"`,
    { stdio: 'inherit' },
    null,
    true
  )
  // recreate any existing auto generated folders
  await utils.recreateFolder(pdfjsServerProjectsDir, true)
  await utils.recreateFolder(percyAutoGenConfigFolder, true)

  // copy projects directory from user's project folder to PDFJS local server folder
  await utils.copyFolder(userProjectsSourceDir, pdfjsServerProjectsDir, true)
}

async function readPdfDocsRunInfoConfigs () {
  return await utils.loadYmlObj(await utils.readFile(defPdfConfigFilePath, fileEncoding))
}

async function triggerPercyProcess (
  percyConfigFilePath,
  percyBranch,
  percyTargetBranch
) {
  // Trigger Percy built-in automation to process the relevant autogenerated Snapshot Files.
  console.info(
    `Triggering Percy Build | percy snapshot "${percyConfigFilePath}" with PERCY_BRANCH = ${percyBranch.replace(
      /\s/g,
      ''
    )} and PERCY_TARGET_BRANCH = ${percyTargetBranch.replace(/\s/g, '')}`
  )
  await utils.startExternalProcess(
    'npx',
    [`percy snapshot "${percyConfigFilePath}"`],
    {
      shell: true,
      stdio: 'inherit',
      env: {
        ...process.env,
        PERCY_BRANCH: `${percyBranch.replace(/\s/g, '')}`,
        PERCY_TARGET_BRANCH: `${percyTargetBranch.replace(/\s/g, '')}`
      }
    }
  )
}

function createPdfDocsRunInfoMap (
  rootConfig,
  allIncludedFilesMap,
  fileName,
  projectFolderName,
  pdfPageCount
) {
  // Create Mapping of Incoming YML file with few additional attributes

  pdfDocsRunInfoMap = {
    runMode: rootConfig.runMode,
    baselineDir: rootConfig.baselineDir,
    releaseDir: rootConfig.releaseDir,
    pdfDocId: '',
    projectFolder: projectFolderName,
    pdfFileName: fileName,
    pdfPageCount,
    includePages:
      allIncludedFilesMap.get(fileName) === undefined
        ? []
        : allIncludedFilesMap.get(fileName).includePages,
    excludePages:
      allIncludedFilesMap.get(fileName) === undefined
        ? []
        : allIncludedFilesMap.get(fileName).excludePages,
    percyBranch: '',
    percyTargetBranch: '',
    finalWorkingDir: '',
    percyConfigs: rootConfig.percyConfigs
  }

  // Set appropriate environment variables and working folder as per PDF Docs Run Info User config file.

  if (pdfDocsRunInfoMap.runMode === acceptableRunModes.configureBaseline) {
    pdfDocsRunInfoMap.finalWorkingDir = pdfDocsRunInfoMap.baselineDir
    pdfDocsRunInfoMap.pdfDocId = `${percyDefaultBranchPrefix}_${projectFolderName}_${pdfDocsRunInfoMap.finalWorkingDir}_${fileName}`
    pdfDocsRunInfoMap.percyBranch = `${pdfDocsRunInfoMap.pdfDocId}`
    pdfDocsRunInfoMap.percyTargetBranch = ''
    pdfDocsRunInfoMap.releaseDir = ''
  } else if (
    pdfDocsRunInfoMap.runMode === acceptableRunModes.compareReleaseWithBaseline
  ) {
    pdfDocsRunInfoMap.finalWorkingDir = pdfDocsRunInfoMap.releaseDir
    pdfDocsRunInfoMap.pdfDocId = `${percyDefaultBranchPrefix}_${projectFolderName}_${pdfDocsRunInfoMap.finalWorkingDir}_${fileName}`
    pdfDocsRunInfoMap.percyBranch = `${pdfDocsRunInfoMap.pdfDocId}`
    pdfDocsRunInfoMap.percyTargetBranch = `${percyDefaultBranchPrefix}_${projectFolderName}_${pdfDocsRunInfoMap.baselineDir}_${fileName}`
  } else {
    console.error(
      `'runMode' found: ${pdfDocsRunInfoMap.runMode}.\nIt should be either '${acceptableRunModes.configureBaseline}' OR '${acceptableRunModes.compareReleaseWithBaseline}'.\nPlease update ${defPdfConfigFilePath}.`
    )
    process.exit(1)
  }

  return pdfDocsRunInfoMap
}

async function createPercySnapshotConfig (pdfDocsRunInfoMap) {
  const additionalSnapshotsForEachPage = []

  let snapshotPagesArr = Array.from(
    { length: pdfDocsRunInfoMap.pdfPageCount - 1 },
    (_, index) => index + 2
  )

  snapshotPagesArr =
    (await pdfDocsRunInfoMap.includePages.length) === 0
      ? snapshotPagesArr
      : snapshotPagesArr.filter((value) =>
        pdfDocsRunInfoMap.includePages.includes(value)
      )

  snapshotPagesArr =
    (await pdfDocsRunInfoMap.excludePages.length) === 0
      ? snapshotPagesArr
      : snapshotPagesArr.filter(
        (value) => !pdfDocsRunInfoMap.excludePages.includes(value)
      )

  console.info(
    `Pages considered for snapshot in DOC: ${pdfDocsRunInfoMap.pdfDocId.replace(
      /\s/g,
      ''
    )} => [1,${snapshotPagesArr}]`
  )
  for (let index = 0; index < snapshotPagesArr.length; index++) {
    const item = snapshotPagesArr[index]
    const nextIndex = item
    let currentIndex = 1
    let percyDynExecuteScriptBeforeSnapshot =
      "let nextIndex = $$dynamicNextIndex$$;\nfor(currentIndex = $$dynamicCurrentIndex$$;currentIndex < nextIndex; currentIndex++)\n{\ndocument.querySelector('div#viewer').children.item(0).remove();\n}\ndocument.querySelector('div#viewer').children.length == 1\n  ? document.querySelector('button#next').click()\n  : document\n      .querySelector('div#viewer')\n      .children.item(1)\n      .scrollIntoView();\ndocument\n  .querySelector('div#viewer')\n  .children.item(0)\n  .scrollIntoView();\n"
    currentIndex =
      snapshotPagesArr[index - 1] === undefined
        ? currentIndex
        : (currentIndex = snapshotPagesArr[index - 1])
    percyDynExecuteScriptBeforeSnapshot = percyDynExecuteScriptBeforeSnapshot
      .replace('$$dynamicNextIndex$$', nextIndex)
      .replace('$$dynamicCurrentIndex$$', currentIndex)

    additionalSnapshotsForEachPage.push({
      suffix: ` | Page ${item}`,
      waitForSelector: percyWaitForSelectorCss
    })

    if (
      pdfDocsRunInfoMap.includePages.length === 0 &&
      pdfDocsRunInfoMap.excludePages.length === 0
    ) {
      additionalSnapshotsForEachPage.forEach(object => {
        object.execute = percyExecuteScriptReferenceObj
      })
    } else {
      additionalSnapshotsForEachPage.forEach(object => {
        object.execute = percyDynExecuteScriptBeforeSnapshot
      })
    }

    if (pdfDocsRunInfoMap.percyConfigs?.waitForTimeout !== undefined) {
      additionalSnapshotsForEachPage.forEach(object => {
        object.waitForTimeout = pdfDocsRunInfoMap.percyConfigs.waitForTimeout
      })
    }
  }

  const snapshotConfigObj = {
    'base-url': pdfServerBaseUrl,
    references: {
      'restore-page-state': `${percyStaticExecuteScriptBeforeSnapshot}`
    },
    snapshots: [
      {
        name: pdfDocsRunInfoMap.pdfFileName,
        url: `${pdfViewerUrlPath}/${pdfDocsRunInfoMap.projectFolder}/${pdfDocsRunInfoMap.finalWorkingDir}/${pdfDocsRunInfoMap.pdfFileName}`,
        waitForSelector: percyWaitForSelectorCss,
        waitForTimeout: pdfDocsRunInfoMap.percyConfigs?.waitForTimeout,
        additionalSnapshots: additionalSnapshotsForEachPage
      }
    ]
  }

  return snapshotConfigObj
}

async function cleanseYmlFile (ymlContent) {
  ymlContent = await utils.replaceContentInFile(
    ymlContent,
    'restore-page-state: |',
    'restore-page-state: &restore-page-state | '
  )

  ymlContent = await utils.replaceContentInFile(
    ymlContent,
    /execute: '\*restore-page-state'/g,
    'execute: *restore-page-state'
  )

  return ymlContent
}

async function processPdfDocsRunInfoConfigs (rootConfig) {
  try {
    if (rootConfig.projectFolders != null) {
      for (const projectFolderName of rootConfig.projectFolders) {
        console.info('Project folder found: ' + projectFolderName)
        const projectReleaseFolderPath = `./projects/${projectFolderName}/${rootConfig.baselineDir}`
        let allIncludedFiles = utils.getFileNames(
          projectReleaseFolderPath,
          '.pdf'
        )

        if (rootConfig.includeDocs != null) {
          allIncludedFiles = await utils.filterDocs(rootConfig.includeDocs, projectFolderName, allIncludedFiles, true)
        }

        if (rootConfig.excludeDocs != null) {
          allIncludedFiles = await utils.filterDocs(rootConfig.excludeDocs, projectFolderName, allIncludedFiles, false)
        }

        if (allIncludedFiles.length === 0) {
          console.warn(`There are no PDF files in the folder ${projectReleaseFolderPath} or they have got excluded based on the PDF Run Info Config file provided.`)
          continue
        }

        let allIncludedFilesMap = new Map()

        if (rootConfig.specialDocConfigs != null) {
          allIncludedFilesMap = await utils.applySpecialDocConfigs(rootConfig.specialDocConfigs, projectFolderName, allIncludedFiles)
        }

        for (const fileName of allIncludedFiles) {
          const pdfPageCount = await utils.getPDFPageCount(`${projectReleaseFolderPath}/${fileName}`)

          const pdfDocsRunInfoMap = createPdfDocsRunInfoMap(
            rootConfig,
            allIncludedFilesMap,
            fileName,
            projectFolderName,
            pdfPageCount
          )
          const snapshotConfigObj = await createPercySnapshotConfig(
            pdfDocsRunInfoMap
          )

          let ymlSnapshotConfigStr = await utils.dumpObjToStr(snapshotConfigObj)

          ymlSnapshotConfigStr = await cleanseYmlFile(ymlSnapshotConfigStr)

          const percyConfigFilePath = await utils.writeContentToFile(
            ymlSnapshotConfigStr,
            percyAutoGenConfigFolder,
            percyAutoGenConfigFileNamePrefix +
              pdfDocsRunInfoMap.pdfDocId
                .replace(/\s/g, '')
                .replace(/\..+$/, '') +
              percyAutoGenConfigFileExt,
            fileEncoding
          )

          // Used when `createNewBuildPerDoc: true` flag is provided in the PDF Run Info Config file.
          // In this case, a new Percy build is created for every PDF documents in scope, across User Projects.

          if (
            rootConfig.createNewBuildPerDoc != null &&
            rootConfig.createNewBuildPerDoc
          ) {
            await triggerPercyProcess(
              percyConfigFilePath,
              pdfDocsRunInfoMap.percyBranch,
              pdfDocsRunInfoMap.percyTargetBranch
            )
          }
        }
      }
    }
  } catch (e) {
    console.error(e)
  }
}

// Used by default to create a single Percy build for all the PDF documents in scope, across User Projects.
async function triggerConsolidatedPercyRun () {
  const ymlConfigFiles = await utils.listFolderYmlFiles(
    percyAutoGenConfigFolder
  )

  if (ymlConfigFiles.length !== 0) {
    const mergedYMLOutput = await utils.mergeMultipleYmlFiles(...ymlConfigFiles)
    const mergedFilePath =
      percyAutoGenConfigFileNamePrefix +
      'mergedMultiplePDFDocs' +
      percyAutoGenConfigFileExt

    await utils.writeContentToFile(
      mergedYMLOutput,
      percyAutoGenConfigFolder,
      mergedFilePath,
      fileEncoding
    )

    pdfDocsRunInfoMap.runMode === acceptableRunModes.configureBaseline
      ? await triggerPercyProcess(
          `${percyAutoGenConfigFolder}/${mergedFilePath}`,
          pdfDocsRunInfoMap.baselineDir,
          pdfDocsRunInfoMap.releaseDir
      )
      : await triggerPercyProcess(
          `${percyAutoGenConfigFolder}/${mergedFilePath}`,
          pdfDocsRunInfoMap.releaseDir,
          pdfDocsRunInfoMap.baselineDir
      )
  } else {
    console.warn(`No Percy YML config files were generated in the ${percyAutoGenConfigFolder} folder. Aborting process.`)
  }
}

(async () => {
  try {
    await readArgs()
    await setup()
    utils.createDir(percyAutoGenConfigFolder)
    const pdfDocsRunInfoConfigObj = await readPdfDocsRunInfoConfigs()
    await processPdfDocsRunInfoConfigs(pdfDocsRunInfoConfigObj)
    if (
      pdfDocsRunInfoConfigObj.createNewBuildPerDoc == null ||
      !pdfDocsRunInfoConfigObj.createNewBuildPerDoc
    ) {
      await triggerConsolidatedPercyRun()
    }
  } catch (e) {
    console.error('Encountered Fatal Error: ' + e)
    throw e
  } finally {
    utils.emptyDir(percyAutoGenConfigFolder)
  }
})()
